Now, I'd like to talk a little bit about how we implement the tree descriptive markup solution. And this is going to be an overview of XML which is a language or a meta language for expressing trees with descriptive markup in linear or linear form. All right, here is a sketch of the contents of this video. XML, the schema language, what it is, XML schemas, XML documents. Example of an XML schema in the DTD XML schema language. An example of XML processing or rather, a diagrammatic overview of the general nature of XML processing, XML tools and XML languages. And I know you're probably already, all of you, have some familiarity with XML, at least through HTML. So this is not entirely new to you but I want to emphasize, as always, I want to emphasize certain features of the tree descriptive markup model and XML that are relevant to data creation. An XML document uses a defined set of delimiters with arbitrary element names and attribute value pairs to nest spans of text. If you reflect on the XML documents, you know or the ones you've seen in the previous videos, it's obvious what's going on there. The delimiters, of course, are the familiar angle brackets, and the slash and so on. A well-formed XML document, fits a formal grammar. So a production from a formal grammar along with some other constraints. And doing so, ensures that the document can be parsed as a tree by an XML parser. And then that tree, that data structure, can be handed over to other software applications. I don't want to pretend like there are XML documents that are not well-formed to be an XML document. You need to be well-formed. What it means to be well-formed is to fit a formal grammar and a few other constraints. And the significance of being well-formed is that, a well-formed XML document can be reliably parsed as a tree data structure and handed over to an application. Note that a well-formed XML document need not have a schema that defines the element vocabulary grammar. Instead, it can use arbitrary elements, attributes, and value names. And it can arrange text objects in any way as long as the arrangement does not violate the tree data structure. So there can't be overlaps. For instance, there can't be cycles, there can't be more than one node without a parent and there must be one node without a parent. All those things are part of being a tree. So a well-formed XML document is a tree but it need not be a tree with some particular grammar. Maybe all of our XML documents should have schemas and the schema should be handy. We should be able to use them. But unfortunately, we live in a cruel world and that's not always possible. Sometimes, we have to be content with our formulas. Okay, so the two main things in the XML world are Schemas and Document Instances. Schema is defined a kind of document, like a novel of a particular kind of a technical manual. They might say define a category, genre, class of the document. And they do this by defining a markup language for the document structures relevant to that kind of document which they do, which it doesn't turn by specifying a vocabulary and syntax for the text that we use in the markup language. In particular, what elements can occur in documents or particular type, or patterns these elements may form and what other information might be included optionally about these elements? These things are specified in the schema, such as a document type definition. The Document Instance, is a particular document marked up with a markup language that meets well-formedness constraints, and presumably, also meets the constraints of the schema. So here's an example of a well-formed XML document. This would be an XML document. A well-formed XML document, even if there is no schema for it. Even if the vocabulary and grammar has not been defined. Here on the other hand, is an example of a schema that is defining a vocabulary attack, vocabulary and grammar. Obviously, this particular schema is the schema of work anthology. And if you're familiar with Backus Naur Form formal grammars, you'll see that this uses a lot of the same characteristics, a lot of the same symbols with just more or less the same meanings. Most of the same meanings as extended Backus Naur Form instead, BNF. It says that an anthology must have at least one poem. And a poem contains zero or one title and then, one or more stanzas. A title contains character text, first character text, what that stands for. A stanza contains one or more lines. And a line contains first character data. So this is a schema specified by element of vocabulary and grammar, which is in the DTD schema language, which is based on as I said extended Backus Naur Form grammars. And this is the DTD schema language. Other schema languages provide additional features including additional validation and constraints on content, such as data typing. Here's another DTD. And, I want to point out that this DTD and unlike the first, has a number of declarations for attributes. So, as you see right under the element declaration for poem, which says a poem must have a title followed by zero or one author followed by a verse. Below it is the attribute request for a poem which says that "a poem may have an attribute value pair, where the attribute is editor." And the value is the data typing here, character data. And, it's required you must provide a value for that attribute. And, you're reading about this in more detail and more precision in the general introduction, which has been assigned. Here, you see an example of an XML document that has attribute value pairs. Here for instance, a poem has the attributes value pair editor Sara Porter. The author is the attribute value pair person N320. Now, a few words about validity in XML. An XML document instance is valid with respect to some schema, validity is always with respect to some schema. If it conforms to the declarations in that schema, which is to say, matches the grammar and other constraints. So, nothing out of place, nothing missing, nothing that hasn't been defined, no attributes with values of the wrong type, no references that they are, so on. A validating parser is software that applies the XML schema to an XML document and determines whether or not the document conforms to the constraints specified in schema. Very important tool in declaration. We are day in day out validating XML documents. Making sure that nothing's missing, nothing's in the wrong place, no references are failing, no data types are wrong, it's exactly what we expect it to be. And, with all the transformations that one does in the workplace, it's very easy for things to get out of whack. So, all valid XML documents are also well-formed. XML documents but not vice versa. Testing for validity does require schema but obviously it's a higher bar and it's an important objective in most and I would say, in most workplaces. Merely assuring that your XML document is well-formed really only means that you could hand it over to software and it'll be parsed as a tree. But, you could have lost pieces, you could have pieces in places where they don't belong, you could have texts and elements which haven't been declared, came from some other place. A lot of things can be, in a sense, wrong with the well-formed document. Having a schema and testing your XML documents for validity, it's a good thing. Keep us all safe. Okay. This is just kind of a overview of how these pieces work together. The XML parser here, takes as input declarations. That's, you know, the grammar and other constraints. In a document instance, checks the document instance against schema. Let's you know if there are any errors and also tells you whether or not it's valid and whether or not it's well-formed. Of course, if it's valid, it's well-formed. So it might say it's not valid but it is well-formed. Often the parser will reorganize this data making a number of changes that help it be better processed by software such as propagating defaults. And, the data is then passed on to an XML application, which typically, reads in as well as the data. Other instructions, perhaps a stylesheet, maybe a CSS stylesheet, XSLT stylesheet, something else. Maybe queries. Maybe transformations. And, as a result produces output. Okay, here's some important XML tools and schema languages other than DTDs. So two XML transformation tools, extremely important. I highly recommend you take a look at them. XSLT and Xquery. Used day in day out for managing textual data. And that includes structured data as well, when it's in XML interchange format. These are very powerful, and to be honest, very CV enhancing skills to have, XSLT and Xquery. There are two XML schema languages that are important in addition to DTDs. One is XML Schema, which is a more functional schema definition language, more complicated but with more features. But, it also has some better data typing which is used in many business applications, it's also used in many data definition applications. RelaxNG is also a very popular XML schema language especially in the publishing community. And, here are some important XML languages for documents. Just picked three and you should be familiar with these. Well, you already are familiar with XHTML, I'm sure but surf around the site, see what's going on. The text and coding initiative is one of the most impressive applications of XML that's out there. It's optimized for culturally important text. And, it's used extensively in digital libraries and in the digital humanities. JATS, the Journal Article Tag Suite, is used for scientific journal articles and it is now being used in almost every scientific publisher,with the exception of three or four. Those happened to be three or four big ones. But, with the exception of three or four use these XML text set developed by the National Library of Medicine or by contractors for the National Library of Medicine. Take a look. And finally, I recommend surfing to the Wikipedia article of excellent markup languages. You'll see there is any enormous number of XML markup languages. And, most of these languages are actually not for text, which may seem surprising, since XML was originally designed to support the management of textual data and is well suited to that. But, most of the languages of the list are actually for the actual interchange preservation formats for highly structured data. XML has become a very important preservation format, very important interchange format. It's use of simple ASCII text with inline tags could be part that can be parsed as schema. If schema is available, it can be validated. Show you you're correct grammar. If you missing anything in place etcetera. Data type. These features may get a very handy language for preservation and interchange. Okay, and with this slide, we've now reached the end of the last video in the week on the tree model. Next week, Ontologies. See you there.