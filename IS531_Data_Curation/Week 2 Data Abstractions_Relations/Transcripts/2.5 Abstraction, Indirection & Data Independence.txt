This is a short video and partly because, what it's about is extremely important. And, I figure a short video might do a better job of keeping these very fundamental things foregrounded in our minds. So, abstraction, indirection, data independence. And, you've heard these things earlier in the other videos, but it's worth saying it one more time, and I'm afraid it's not going to be the last time either, because these will be constant themes in the weeks ahead. The success of the relational model in meeting the challenges of the problematic situation that I described, is based primarily on two related principles: abstraction and indirection. So, the relational representation, abstracts away from the specific and transient details of storage, and presents only the intrinsic features of the data itself. That's the magic, right there. Subsequent interaction with the stored data is then indirect. Whether you're maintaining the data, analyzing, viewing, it's indirect. It takes place not by a direct engagement with stored data, but via a mapping from the relational schemas to the store data. Here's a picture of that. And, I bet you've seen this picture before or one like it. It's from the NC approach to understanding this kind of mapping that actually was happening in the 60s and 70s. Now, let's take a look at how exactly mapping accomplishes the management of data independence and achieve data independence. How it does its magic. So, remember there are two kinds of data independence: physical data independence, which means a physical schema storage method can change without affecting interactions of the data, and logical independence, which means the logical schema can change without affecting interaction with the data. So, with physical independence, the problem with direct interactions with data is that if the storage method switches from a fixed field approach to a delimited field approach, then the access programs and other tools are going to return the wrong results. The solution is that, there is a mapping from the physical schema to the logical schema, and this mapping is adjusted in order to accommodate changes in the physical storage methods and we've seen that. Now, logical data dependence. So here, the kind of problem we're concerned with, is that if a new attribute is added but it's accommodated at the physical level by adding say, a delimited field to the right side of a record, then any program or other tool that's been identifying fields by counting delimiters right to left, is probably going to return the wrong result. The solution though is exactly the same. Again, we have the physical schema mapped to a logical schema. And the mapping is adjusted, so that when you wish you were query for instance, or an update or deletion, by using query as an example, when you issue a query, it's mediated first by the logical schema that will allow you to identify attributes and values. And then, that logical schema is mapped to the physical schema and you're going to find the right values. The values you hope to find, tend to find, because the adjustments have been made. And this is worth, I think one more slide, abstraction, implemented with an indirection supports data independence. That's what we've seen this week in how the relational model meets the challenges of the chaotic problematic situation that we describe. This is a fundamental principle in data curation. Abstraction, implemented with indirections supporting data independence, and we'll see it again and again in the course. Thanks, and see you next week.