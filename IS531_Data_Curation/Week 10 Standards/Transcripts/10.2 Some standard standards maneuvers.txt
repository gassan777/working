Welcome back everyone. This is the Standards Week. This is video two in the Standards Week. Some standard standards maneuvers. That may not be totally lucid title for this video. You make some observations about some things that standards do in order to be effective and manage the challenges they face that you may be aware of them or you may not, and they provide insights. They provide insights into standards in general. So, this is one that I'm sure you've noticed. It is extremely important. We live in a very, very complex world, and it would not be possible unless standards were built on standards. And standards are built on standards, they're built on standards in a wide variety of ways. If you take a close look at almost any standard of any kind in the data and more generally, the IT world, XML, ePUB, JSON, anything or networking standards or process, anything practically, you'll see that these standards are based on other standards. So for instance, a standard markup language, doesn't need to define its own schema language. It can specify for instance XML schema, and XML schema in turn, doesn't need to define its own character encoding standard. It can specify unicode. Simple example, take a look at these standards and you'll see that in fact, it's pretty complex. So, this hierarchy of standards. It's not always agile. As I say here, it's considerable complexity of breadth and depth and especially, if what's called subsetting takes place. Subsetting is when only portions of the subordinate standards are allowed by the superordinate standard. And this can make production and validation very complicated for the Including standard, because applications need to know that only part of the subordinate standard is legit and produce an error or at least to comment if its outside of the subset are used. And this of course means that using existing modules from libraries that are focused on the subordinate standard, can become quite complicated because those modules in libraries will process the entire subordinate standard and not see any violation. What's important though, what's useful though, about this is it could simplify things for applications downstream. So, it might complicate things for production, it might complicate things for management, but that app on your phone for instance, does not have to process every single bit of for instance, unicode or XML, in order to read that novel in ePub. So what's going on here is that we subset, we're typically trying to reduce the burden on downstream application developers. But this can increase the work required upstream in production shops. Pretty interesting. Here's a really interesting classic maneuver, and you see kind of versions of it all throughout digital technology. So I call it Meta-standards. It's another case of going Meta. You might even say it's another case of adding another level of indirection. So, imagine that you're trying to get everybody to agree on a particular document markup language, a particular language for marking up documents. It might be LaTex, Scribe, troff-ms, or you might have to make a new one. Suppose you're trying to get a large community of people using different document markup languages to agree to just use one. To use the same way of indicating. This is a formula, this is an extract, this is a title, and so on. So, some people use LaTex, some Scribes, some troff-ms, JATS, and so on. How's that going to go? Not well. Not well. It absolutely, will not be easy, and it may not be possible and yeah, you could get her trying. So, you might recalculate and do a reality check and go meta, and decide not to standardize the markup language itself, but standardize how you define markup language is. That is how you indicate what the tags are, what patterns of use are legitimate, what's required, what's optional, and so on. And do this with a much computer processable formal grammar. So the schemas can be validated and can be used to configure applications. Proceeding like this, you don't have to get so much agreement upfront. And you can still keep trying to standardize the actual language and you might succeed eventually. Perhaps, just because the world evolves, kind of a genetic drift or something that just ends up in the right place, or ends up in a place with everyone together. But in the meantime, you have a standard way of defining markup languages, and that standard is machine readable, and that is going to get you very far. It may in fact get you as far as it's possible to go. It may be temporary but in any case, you're going to need a standard for defining markup language any way, because that standard is going to be schema and you're going to need a schema. So, going meta, it's often a good idea. Standardizing being nonstandard. It's an interesting one. So standards you probably know, can be extended in many ways. One example, the XML. I like XML examples, you can tell. XML internal subset lets elements and attributes be added to a schema in a systematic way that ensures continued validation. In fact, your additions are themselves validated according to the bits of formal grammar that you add. That's very cool. You need to add something, you can do it. You can do it by play in the video, by playing by the rules as you should, you continue to get a lot of the benefits of the larger standard. And sometimes it's possible to use completely non-standard constructs, and in that case, you might have an escaped segment in your data, and then the processor really doesn't look at it to do much. It certainly doesn't do validation. Now, and the goal here is always when you depart from a standard, it departs to the right word. In some cases, it is, in some case, it isn't. But when you extend, when you adapt, when you depart, you want to do this as gracefully as possible. So, an example of doing it without any grace whatsoever is what happened a gazillion years ago. It's heads for Netscape introduced the 'blink' tag. You don't want to just start using a construct in your data because you want it and because your apps can deal with it, right? That's not very social. I've been a good citizen. So, you can introduce the 'blink' tag for instance, not in the HTML standard when Netscape introduced it. Your apps blink, but what are other apps going to do? Who knows? Back in the day when this happened, there was no validation taking place, so the 'blink' tag just slid through as an element tag, a generic identifier, but it wasn't rejected because it was included in the HTML schema because browsers were not validating against this schema. But the bad thing, of course, is that it does showed up, either showed up as 'blink', B L I N K in brackets or didn't show up at all because it looked like a tag. Who knows, and this is a little simple, if somewhat, well known example, but in other cases, you can cause considerable damage to property, people, and plants. What you want to do is to- if you add a construct to your data description line, but you want to add it to the schema, so then at least it's not going to break validation, and also it can be used in the configuration of applications. Now, when you add it to the schema, all you're really doing is saying this thing whatever it is, is part of the syntax and maybe saying here are the rules, here are the grammar rules, that allow you to validates in the right place. Even better, is to do that and document the addition so that everyone knows what it means or what it does. So you want to attend to both syntax. Grammar, let's say, and grammar and meaning here. Grammar and semantic, syntax and semantics. So standards themselves can also support these kinds of extensions and departures, and they do it in a wide variety of ways. Some of them pretty, pretty, pretty fascinating. But let's take one example, and it's kind of a simple one that I'm familiar with for my standards work. The open electronic book publication structure working group, which was producing the predecessor for the epub standard. I wanted to make it possible for content providers and software developers to do interesting things, but we also didn't want to break existing readers. We didn't want to put burdens on content developers and we didn't want a lot of confusion when you read a book on one device, and then the person next door read it on the other and get different results. So to solve was a challenge, it's standards development, you want to support innovation, you want to support competition. [inaudible]. You want to support competition and that means you want to support innovation, but innovation is, I'm tempted to say, it's exactly what standards see is problematic. Standards are about standardizing innovation, it's about doing something new. How can you have both at the same time? Well, you can and you should. You can get a lot of the advantages of both, but it's a lot of work. So here's what you can do. First of all, add it to the schema, then it will break validation and can be used usefully to configure applications, document it. All was a good idea, but also map your innovative new construct to some relevantly similar or at least serviceable standard construct that will approximate the meaning of the nonstandard element or is an appropriate alternative action. I use a 'blink' tag as an example. If you were going to use the 'blink' tag in a way that was responsible civic minded, you would add it to the schema, at least using the approach that X amount allows when you add your own construct to an existing schema that you don't own. You add it to the schema, you document it, and you map it to something other than blinking. You know all conformant processors will be able to do, such as bold. So now, the processor and the counters blink, it can't blink because, that's right, it's not Netscape and with the whole idea. It can't blink, but it sees that the alternative to blinking is bold, and so, it puts it in bold. Simple example, but I'm perfectly illustrative of what a fallback is. So standards can specify a fallback mechanism that will allow you to introduce unique innovative things, and yet, do so in a way that will not break validation, and also, that will provide an alternative action, or rendering, or interpretation so that existing applications, or applications even in the future that only conform to the published accepted standard won't break. Okay, and that's it for this video. See you soon.