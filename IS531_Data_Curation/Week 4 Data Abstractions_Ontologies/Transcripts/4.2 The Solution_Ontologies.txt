This is the video on the solutions. So first, a review of the problem, and then we outline the solution from a historical point of view. I'm quite fond of the historical point of view so pardon me if this sounds archaic. It's not. So, Entity Relationship Modeling, which is the emergence of the ontological perspective on data, in my opinion, in the 20th century. What it is and then why it works. And then we generalize two ontologies generally. What they are and how they look today when they're implemented. They often are in RDFS now. So just to begin with a kind of a spoiler, but it's important enough to risk spoiling the drama. Ontologies provide a way to abstract away from data structures such as tables and trees and focus on information, which is to say focus on facts about things and relationships, the domain of interest. And from that, many data curation advantages ensue. We ended the last video by saying we lack a shared framework that could explicitly and formally map the relevant features in the domain of interest, the real world, to the relation or tree schemas holding data about those things. This framework, if we had it, could be used to guide relations and tree schema development, formally, explicitly, systematically, methodically, and also guide revisions, and more generally help identify common domain features that are reflected in different relation entry schemas and can help with conversion for that reason. In effect, such a framework would also provide relation and tree schemas with a semantics. And as a consequence of that, their instances, the relations and trees, would have meaning and assert propositions, which they really don't know. Because without the kind of framework we're talking about, you really don't know formally what a relation or an XML document is telling us. It's in your head, not good enough. Need one more level of abstraction. OK, what's the solution? How did it emerge historically? In 1976, Peter Chen proposed a simple solution to this problem and here's my interpretation of it. Conceptualize your domain of interest in terms of its things, relationships, etc. And then, map that conceptualization to whatever logical models, schemas are being used, whatever tree or relational schemas are being used. Sounds familiar? Should sound familiar. This also changed the world. And if you haven't at least browsed this very influential paper indicated below, you have to. It's pretty interesting. So here are graphic visualizations of the entity relationship model. And I'm sure you're all familiar with them. We got rectangles, arrows, ovals. It's an ER diagram, and it's similar as well to UML class diagrams. So what's going on here? You know, but let's take a closer look. It's the foundation of the entity relationship model in first order logic that gives it its real power. I know it's convenient to use boxes and arrows when you're got a group of people planning a system, but it's the foundation in logic that makes the ER model a early form of ontologies and gives it the full range and power that it has. So, there are the diagrams, rectangles, ovals, arrows. What do they mean? Intentionally, we use the words intentionally and extensionally, what they mean I think will be apparent. Or you can look them up. Intentionally, rectangles in an ER diagram indicate a kind of entity or type of entity. Extensionally, those rectangles are sets of entities of a particular type. And if you remember your set builder notation, there it is, the set of all x's that satisfy x is f. Intentionally, attributes are dyadic predicates in logic. Extensionally, they are function mapping entities to value in a domain. So in first order logic, there's an example, the obvious example of how we define a function as a set of tuples that meet a certain constraint. Intentionally, relationships are also dyadic predications but they're subject to a range of possible cardinality and participation constraints. And that makes their extensional representation more complicated. It doesn't matter for our purposes. You can see here, the kind of logical foundation the ER model has. You're wondering but so what? Why is that important? We now have a description of the structure of the domain, a specification of the real world, things, attributes, and relationships in that domain. And as you know, this kind of description is called a conceptual schema, it's at the conceptual level, ER diagrams, UML, so on. Even before ontologies were considered descriptions of a domain that existed, the conceptual level. Now a conceptual schema is really about the world and this is easy to see when you've looked at its logical foundation. The predicates, the logical predicates, just take a look at them. Right there, FR. The logical predicates are intended to correspond to real world properties. They are not simply names of domains. The variables are intended to range over real world individual things, things in the world, explicitly, not just be interpreted that way by the reader. That's what they do. So connecting a conceptual schema like this one to a logical level schema can give the instances of that logical schema meaning, formalizing how they express propositions, how they express information about the world. And somewhat more practical point of view, conceptual schemas now directly address and I would say solve the problem described earlier. They can be used to guide the development of logical schemas or characterize the common meaning or core of two different schemas that are partially or totally equivalent. Finally, but by no means least, perhaps most importantly from the data creation point of view, conceptual schemas provide critical documentation of the data set. You really want a conceptual schema as well as a logical schema with your data set. You get a lot more information. And if that conceptual schema is machine-readable or formal, so much the better. Now you might be wondering, but in this case, where does the mapping occur? And one answer is that it occurs at a particular point in time rather than being continued to serve as the foundation for access. So the most common use of conceptual models is to create logical schemas and you all did this in your database course. It involves the step by step generation of relational schemas from an ER schema. The algorithm for this and there are many examples for that on the Web if you want a refresher. So the mapping happens when you generate the relation schemas in a database from the ER schema through that algorithm that we all heard, that recipe. Another data creation point, if your relational schema was generated mechanically from an ER schema, that ER schema reliably documents, maybe not completely but partially, the relationship between your view of the domain and your relational schema. It's very valuable to know that, obviously, but it's also very cool that this is generated mechanically. That is you developed the ER diagram, I would say, as your conceptual model and then following the recipe, you generated the relation to the relational database. That ER diagram is now documentation. Pretty nice. A few words about what Conceptual Modeling typically looks like today. We, as often as not, don't use attributes anymore since attributes, like our dyadic predications, just like relationships. So we could just use relationships and some of them are many to one in some functions. And in addition, we almost always add class relationships when we're doing conceptual modeling. They didn't always use class relationships in ER modeling. And here, you can see the class relationships, as well. Double arrow frequently say that in UML but just to make sure you get the point, I put in the subset symbol. So you might have noticed that we've talked about two kinds of data models that exist at the logical level in the diagram we saw. But now, we've moved up to the conceptual level without talking about the other data model at the logical level. And that's because it's easiest to talk about that other logical level data model after we've talked about ontologies. So now, we're getting our first look at, of course, an RDF graph. Okay. So, interesting story, the emergence of contemporary ontologies sparked interest in a logical level data model that had not been particularly important in the late 20th century and that is simple dyadic predication. But simple dyadic predication makes its sort of renewed and newly ambitious appearance as the RDF triple. Typically represented with this generic graph model which indicates that a certain thing, in this case, we imagine that it's a work. In fact, it's the work we're looking at earlier, Moby Dick. And it's creator is a person indicated by orchid ID. The creator predicate has the name space DC because it's Dublin Core RDF triple. This is a graphic representation of the subject-predicate-object or triple construct which exists at the logical level. If you look back at your diagram, I'm introducing it now because it's convenient to connect it with an ontology of the RDF S type, it's not RDF S explicitly. So that you can see how a schema for an ontology gets connected to a particular data instance at the logical level. Okay, now here's how it all hangs together. Above the red line, you see a conceptual schema or ontology. Below the red line, we have you might say a fact expressed with an RDF triple. And because we are saying something about the world, not just storing data, you can see that the schema is a schema about things and that in the triple, the classification is about the things in the proposition, expressed by the triple. In this case, there's a person, there's a work and there's authorship or creation. We're not data typing the data. When you move up from the logical level to the ontological level to the conceptual level, we're talking about the world, so the classifications are of kinds of things in the world. That's a big step from the focus on data to the focus on things. It's a step that's easy to miss sometimes because there's a lot of structural similarity. And here's a good example. We have our RDF triple expressed in a graphic visual visualization. And then we have an example of how it might be expressed in a serialized form like such as N3. And we can also see how this is consistent, in a sense, with the organization of a relation. In this sense, we can generate triples by starting with the primary key going to the column heading for the predicate and then the value for the object, primary key column heading value. And in fact, I'm sure, you can store the URIs that are used in an RDF triple in a relational database. Not a problem. At the same time, also note that you can conceptualize this serialization of RDF statements in N3 as a relation, same-size tuples. Not as compact. This is not as compact as this relation but it's the set of same-size tuples, set of N3 triples. This is also a set of tuples, four-sized. There are a lot of structural similarities taking place but they shouldn't distract us from the fact that when we're looking at a conceptual model or an Ontology, the schema is a schema of features of the domain, and that's what allows us to interpret things at the logical level because this is at the logical level, interpret things at the logical level as expressing facts, propositions about that domain, about that world. All right, now, let's generalize a bit. We've been talking about ER diagrams and I've been using the word Ontology sometimes and ER diagram and conceptual model and so on somewhat synonymously, but I do want to give the classic definition of what an Ontology is. And I think you'll agree with me that the classic definition does really spell out a very broad inclusive concept. So, the classic definition of Ontology, the sense of it used in Information Science, Computer Science, an Ontology is an explicit specification of a conceptualization of a domain. That's the definition, and Tom Gruber goes on to say these other things by way of explication. A body of formally represented knowledge is based on a conceptualization. He means more or less what we mean by schema. By body of formalized represented knowledge, he means more or less the instance relation tree triple that actually expresses a particular proposition, a certain fact. The objects, concepts and other entities that are assumed to exist in some area of interest and the relationships that hold between them, that's the conceptualization. A conceptualizaton is an abstract, simplified view of the world that we wish to represent for some purpose. Every knowledge-based system or knowledge-level agent is committed to some conceptualization, explicitly or implicitly, and this lets me make the point again that we had in our heads all along when we were making relational databases. We had conceptualizations in our heads. We had Ontologies in our heads implicitly. What we need to do to solve the problems that come from this lack of clarity, lack of recording, lack of explicitness, lack of machine readability, is get the Ontology out of our head and get it into a formal notation. So, it's a big tent but I do want to indicate not the differences between conceptual models and Ontologies, but the differences in the connotations, you might say, of these two terms. As I said, I don't see any useful distinction between conceptual models and Ontologies. Going forward, I'll be using Ontologies to include models like ER, entity relationship modeling. Here, though, are the slight differences of emphasis: Ontologies almost always have class relationships and perhaps are often an extensive class hierarchy. Ontologies will often include very abstract concepts such as physical object, set, event, time interval, property, number, and so on. Ontologies are usually intended to be relatively stable and multi-purpose. They're sometimes accompanied by logical axioms that support inferencing. There's sometimes a very specific formal technique that's used in development and, sometimes, in Ontology development, minimizing the number of kinds of entities is an objective. So, these things are sort of roughly distinguished by emphasis, the connotation of conceptual model in Ontologies, but it's not in a difference that I'm going to pay much attention to from now on. You may have noticed that in most of this discussion, we focused on the connection between conceptual models or Ontologies and relational schemas. You might wonder, what about the tree model? What about those XML documents with descriptive markup? They're really important, they're everywhere. Don't they get an Ontology? How do we map an Ontology to an XML schema? Interesting question. It turns out that the semi-structured nature of XML documents makes it extremely challenging to develop a conceptual model that will play the same semantic role for them as ER diagrams do for the relational model. And some colleagues of mine have done some research on this topic, and if you're interested, you might take a look. The XML documents and the XML approach to organizing textual information runs into the very same problems, exactly the same problems, as the relational model. And they're not noticed right away for the same reason but they are much harder to remedy. If the name Michael Sperberg-McQueen sounds familiar, Michael is one of the three editors of the XML standard. And I'm going to close with the picture I introduced earlier, now that we are fleshing it out a bit. At the logical level, we have the relational model, the tree model and RDF triples. We've now introduced conceptual models including the ER model, UML model, they're about the same Ontologies, the focus there is on entities and relationships, specific kinds of schemas like ER UML and any relationship and UML modeling is focused on relations. RDFS and OWL provide the conceptual model for RDF triples. And I can't say that anyone has yet provided a conceptual model for XML trees. I'd like to think, I know that Michael and Klaus, Dave Dubin and I would like to think that maybe we've almost gotten there but I don't think we quite have earned our place on this chart. Okay. That's it for this video. I'll see you soon in the next one.